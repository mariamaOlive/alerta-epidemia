///////////////////Carregando Dados//////////////////////////////
//Colocar csvs nessa pastas
C:\Users\mcso\.Neo4jDesktop\relate-data\dbmss\dbms-69782ce3-52fa-480a-8249-0bafb6cbe2a3\import

// WITH "https://github.com/mariamaOlive/alerta-epidemia/tree/main/data/integrado/" AS base
// WITH base + "municipio.csv" AS uri
LOAD CSV WITH HEADERS FROM "file:///municipio.csv" AS row  with row where row.longitude is not null
MERGE (:Cidade {cod_mun: toInteger(row.cod_mun), nome: row.nome_mun, latitude: toFloat(row.latitude), longitude: toFloat(row.longitude), populacao: toInteger(row.populacao_2021)})

//Updating
LOAD CSV WITH HEADERS FROM "file:///cidades_regic.csv" AS row  
MERGE (c:Cidade {cod_mun: toInteger(row.cod_mun)})
ON MATCH SET c.PIB= toInteger(row.PIB), c.hierarquia= row.hierarquia, 
c.nome_hierarquia= row.nome_hierarquia, c.indice_atracao= toFloat(row.indice_atracao),
c.ia_saude_bm= toFloat(row.ia_saude_bm), c.ia_saude_a= toFloat(row.ia_saude_a),
c.ia_aeroporto= toFloat(row.ia_aeroporto), c.ia_transporte= toFloat(row.ia_transporte),
c.num_leitos= toFloat(row.num_leitos)
//ON MATCH SET n.TotalRevenue = csvLine[2] --> Faz um update
//ON CREATE --> Cria o nó caso precise


//And this query imports relationships:
// WITH "https://github.com/mariamaOlive/alerta-epidemia/tree/main/data/calculado/" AS base
// WITH base + "fluxo_prob.csv" AS uri
LOAD CSV WITH HEADERS FROM "file:///fluxo_prob.csv" AS row 
MATCH (origem:Cidade {cod_mun: toInteger(row.cod_origem)})
MATCH (destino:Cidade {cod_mun: toInteger(row.cod_destino)})
MERGE (origem)-[r:FLUXO{ fluxo_geral: toFloat(row.prob_geral), fluxo_aereo: toFloat(row.prob_aereo), fluxo_rodo: toFloat(row.prob_rodo) }]->(destino)


//Updating relationship
LOAD CSV WITH HEADERS FROM "file:///fluxo_saude.csv" AS row 
MATCH (origem:Cidade {cod_mun: toInteger(row.cod_origem)})
MATCH (destino:Cidade {cod_mun: toInteger(row.cod_destino)})
MERGE (origem)-[r:FLUXO]->(destino) 
ON CREATE SET r.saude_baixa_media = toFloat(row.saude_baixa_media), r.saude_alta = toFloat(row.saude_alta)
ON MATCH SET r.saude_baixa_media = toFloat(row.saude_baixa_media), r.saude_alta = toFloat(row.saude_alta)

//Updating node
MERGE (c:Cidade {cod_mun: toInteger(row.cod_mun)})
ON MATCH SET c.PIB= toInteger(row.PIB), c.hierarquia= row.hierarquia, 
c.nome_hierarquia= row.nome_hierarquia, c.indice_atracao= toFloat(row.indice_atracao),
c.ia_saude_bm= toFloat(row.ia_saude_bm), c.ia_saude_a= toFloat(row.ia_saude_a),
c.ia_aeroporto= toFloat(row.ia_aeroporto), c.ia_transporte= toFloat(row.ia_transporte),
c.num_leitos= toFloat(row.num_leitos)
////////////////////Algoritmos de Centralidade////////////////////////

//Closeness Centrality

CALL gds.graph.project('myGraph', 'Cidade', 'FLUXO')

CALL gds.beta.closeness.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).cod_mun AS id, gds.util.asNode(nodeId).nome AS nome, score
ORDER BY score DESC

//Escrevendo
CALL gds.beta.closeness.write('myGraph', { writeProperty: 'closeness' })
YIELD centralityDistribution, nodePropertiesWritten
RETURN centralityDistribution.min AS minimumScore, centralityDistribution.mean AS meanScore, nodePropertiesWritten

//Betweenness Centrality
CALL gds.betweenness.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).cod_mun AS id, gds.util.asNode(nodeId).nome AS nome, score
ORDER BY score DESC

//Escrever
CALL gds.betweenness.write('myGraph', { writeProperty: 'betweenness' })
YIELD centralityDistribution, nodePropertiesWritten
RETURN centralityDistribution.min AS minimumScore, centralityDistribution.mean AS meanScore, nodePropertiesWritten

//Page Rank
CALL gds.graph.project(
  'myGraph_peso',
  'Cidade',
  'FLUXO',
  {
    relationshipProperties: 'probabilidade'
  }
)

CALL gds.pageRank.write.estimate('myGraph', {
  writeProperty: 'pageRank',
  maxIterations: 20,
  dampingFactor: 0.85
})
YIELD nodeCount, relationshipCount, bytesMin, bytesMax, requiredMemory

CALL gds.pageRank.stream('myGraph_peso')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).nome AS nome, score
ORDER BY score DESC, nome ASC

///Com peso
CALL gds.pageRank.stream('myGraph_peso', {
  maxIterations: 20,
  dampingFactor: 0.85,
  relationshipWeightProperty: 'probabilidade'
})
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).nome AS nome, score
ORDER BY score DESC, nome ASC

//Escrevendo
CALL gds.pageRank.write('myGraph_peso', {
  maxIterations: 20,
  dampingFactor: 0.85,
  relationshipWeightProperty: 'probabilidade',
  writeProperty: 'pagerank'
})
YIELD nodePropertiesWritten, ranIterations

//Article to Rank
CALL gds.articleRank.write.estimate('myGraph', {
  writeProperty: 'centrality',
  maxIterations: 20
})
YIELD nodeCount, relationshipCount, bytesMin, bytesMax, requiredMemory

CALL gds.articleRank.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).nome AS nome, score
ORDER BY score DESC, nome ASC


//Eigenvector Centrality
CALL gds.eigenvector.stream('myGraph_peso')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).nome AS nome, score
ORDER BY score DESC, nome ASC


CALL gds.eigenvector.write('myGraph', {
  maxIterations: 20,
  writeProperty: 'centrality'
})
YIELD nodePropertiesWritten, ranIterations

//Escrever
CALL gds.eigenvector.write('myGraph_peso', {
  maxIterations: 20,
  writeProperty: 'eigenvector'
})
YIELD nodePropertiesWritten, ranIterations


//Degree Centrality
CALL gds.graph.project(
  'myGraph_centrality',
  'Cidade',
  {
    FLUXO: {
      orientation: 'REVERSE',
      properties: ['probabilidade']
    }
  }
)

CALL gds.degree.stream('myGraph_centrality')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).nome AS nome, score AS conexoes
ORDER BY conexoes DESC, nome DESC

//Escrever
CALL gds.degree.write('myGraph', { writeProperty: 'degree' })
YIELD centralityDistribution, nodePropertiesWritten
RETURN centralityDistribution.min AS minimumScore, centralityDistribution.mean AS meanScore, nodePropertiesWritten


//Harmonic Centrality
CALL gds.alpha.closeness.harmonic.stream('myGraph', {})
YIELD nodeId, centrality
RETURN gds.util.asNode(nodeId).nome AS nome, centrality
ORDER BY centrality DESC

//HITS
CALL gds.alpha.hits.stream('myGraph', {hitsIterations: 20})
YIELD nodeId, values
RETURN gds.util.asNode(nodeId).nome AS nome, values.auth AS auth, values.hub as hub
ORDER BY auth DESC

////////////////////Comandos básicos////////////////////////
MATCH (cidade)  
WHERE cidade.cod_mun = 2611606 AND 
RETURN cidade

//Query
MATCH (n)
WHERE n.cod_mun = 2603454
RETURN n
///2611606 --> Recife

MATCH (c1)-[r]->(c2)
WHERE c1.cod_mun = 3550308 AND  c2.cod_mun = 2927408
RETURN c1, c2

MATCH (c1)-[r]->(c2)
WHERE c1.cod_mun = "2927408" 
AND r.probabilidade > 0.015
RETURN c1,c2

MAX


MATCH (c1)-[r]->(c2)
WHERE c1.cod_mun = "2927408" 
AND c2.pagerank > 13
RETURN c1, c2 

//Calculando valor e salvando
MATCH (c1)-[r]->(c2)
WHERE c1.cod_mun = "2927408" 
WITH c1, r, c2
SET c2.salvador = c2.closeness*.1 + r.probabilidade*.9
RETURN count(r)


//Calculo
MATCH (c1)-[r]->(c2)
WHERE c1.cod_mun = "2927408"  
WITH c1, r, c2
RETURN  c2.closeness*.1 + r.probabilidade*.9 



MATCH (c1)-[r]->(c2)
WHERE c1.cod_mun = "2927408" 
AND c2.salvador > 0.1
RETURN c1, c2 

MATCH (c1)-[r]->(c2)
WHERE c1.cod_mun = "2927408" 
RETURN c2.nome AS nome, c2.salvador AS salvador
ORDER BY salvador DESC


MATCH (c1)-[r]->(c2)
WHERE c1.cod_mun = "2927408" 
RETURN c2.nome AS nome, c2.salvador AS salvador
ORDER BY salvador DESC


//CODIGO RETORNAR NOS
MATCH (c1)-[r]->(c2)
WHERE c1.cod_mun = "2927408" 
RETURN c2, c2.salvador AS salvador
ORDER BY salvador DESC LIMIT 10

//Deletar tudo
MATCH (n) DELETE n;

MATCH (n)
DETACH DELETE n

//Remover propriedade de um relatioship
MATCH (c1)-[r]->(c2)
REMOVE r.saude_baixa_media, r.saude_alta


//Cast
match (:Cidade)-[r]->(:Cidade)
where r.probabilidade = toString(r.probabilidade) // make sure we only work string ratings
set r.probabilidade = toFloat(r.probabilidade)
return count(r)


//Consultas feitas no app
MATCH (c1)-[r]->(c2) 
WHERE c1.cod_mun =  2603454
RETURN c2.cod_mun AS cod_mun, c2.nome AS nome, 
r.fluxo_geral AS fluxo_geral, r.fluxo_aereo AS fluxo_aereo, r.fluxo_rodo AS fluxo_rodo, 
r.saude_alta AS saude_alta, r.saude_baixa_media AS saude_baixa_media, 
c2.latitude AS latitude, c2.longitude AS longitude


//Exportar nodes
MATCH (c:Cidade)
WITH collect(c) AS cidades
CALL apoc.export.csv.data(cidades, [], "cidades.csv", {})
YIELD file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, data
RETURN file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, data






//TODO: Remover consultas SQL

sql = """
    UPDATE final_table AS f
    SET PIB= t.PIB, hierarquia= t.hierarquia, 
    nome_hierarquia= t.nome_hierarquia, indice_atracao= t.indice_atracao,
    ia_saude_bm= t.ia_saude_bm, ia_saude_a= t.ia_saude_a,
    ia_aeroporto= t.ia_aeroporto, ia_transporte= t.ia_transporte,
    num_leitos= t.num_leitos
    FROM temp_table AS t
    WHERE f.id = t.id
"""